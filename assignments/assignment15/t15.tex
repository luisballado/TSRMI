%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lachaise Assignment
% LaTeX Template
% Version 1.0 (26/6/2018)
%
% This template originates from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Marion Lachaise & François Févotte
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{TSRMI: Assignment \#15} % Title of the assignment

\author{Luis Alberto Ballado Aradias\\ \texttt{luis.ballado@cinvestav.mx}} % Author name and email address

\date{CINVESTAV UNIDAD TAMAULIPAS --- \today} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\begin{itemize}
\item Documentar el pseudocódigo de los algoritmos Bug1 y Bug2.

  
  %% This declares a command \Comment
  %% The argument will be surrounded by /* ... */
  \SetKwComment{Comment}{/* }{ */}
  \RestyleAlgo{ruled}
  \begin{algorithm}
    \caption{Algoritmo Bug1}\label{alg:one}
    Definir punto objetivo $P$\;
    Inicializar posición actual del robot R\;
    Inicializar posición variable hit como false\;
    \While{$R \notin P$}{
      \eIf{$R$ libre de obstáculos en la dirección hacia P}{
        Mover R hacia $\implies P$\;
      }{\eIf{No se ha encontrado obstáculo anteriormente (hit=false)}{
          Girar R en sentido horario\;
          Marcar posición actual como punto de contacto\;
          Establecer hit como verdadero
        }{
          \eIf{Si R ha vuelto al punto de contacto inicial}{
            Mover R hacia adelante hasta superar el punto de contacto
          }{
            Girar R en sentido horario
          }
        }
      }
    }
  \end{algorithm}


  %% This declares a command \Comment
  %% The argument will be surrounded by /* ... */
  \SetKwComment{Comment}{/* }{ */}
  \RestyleAlgo{ruled}
  \begin{algorithm}
    \caption{Algoritmo Bug2}\label{alg:two}
    Definir punto objetivo P\;
    Inicializar posición actual del robot R\;
    Inicializar posición variable hit como falso\;
    \While{R $\notin$ P}{
      \eIf{$R$ está libre de obstáculos en la dirección hacia P}{
        Mover R hacia $\implies$ P\;
      }{
        \eIf{Si no se ha encontrado obstáculo anteriormente (hit=false)}{
          Girar R en sentido horario\;
          Marcar posición actual como punto de contacto\;
          Establecer hit como verdadero\;
        }{
          \eIf{Si R ha vuelto al punto de contacto inicial}{
            Calcular la distancia a P desde la posición actual\;
            \eIf{Distancia a P desde el punto de contacto }{
              Girar R en sentido horario\;
            }{
              Mover R hacia adelante hasta superar el punto\;
            }{
              
            }
          }{
            Girar R en sentido horario\;
          }
        }
      }
    }
    
  \end{algorithm}
  
  \newpage
\item Una tercera variante, denominada TangentBug, utiliza sensores de distancia en lugar de sensores de contacto. Documentar un artículo científico que emplee el algoritmo TangentBug.

  El algoritmo TangentBug es una variante del algoritmo Bug utilizado para la navegación de robots móviles en entornos desconocidos o con obstáculos. A diferencia de los algoritmos Bug1 y Bug2, el algoritmo TangentBug utiliza sensores de distancia en lugar de sensores de contacto para detectar los obstáculos.\\

  En el algoritmo TangentBug, el robot utiliza sus sensores de distancia para medir la distancia a los obstáculos en su entorno. El objetivo principal del algoritmo es seguir la tangente de los obstáculos para alcanzar el objetivo deseado. A medida que el robot se acerca a un obstáculo, mide la distancia a ese obstáculo en varios puntos alrededor de su posición. Luego, elige el punto en el que la distancia al obstáculo es mínima y se dirige en la dirección perpendicular a ese punto, siguiendo la tangente del obstáculo. Este proceso se repite iterativamente mientras el robot se mueve hacia el objetivo.\\

  La idea central del algoritmo TangentBug es utilizar la información proporcionada por los sensores de distancia para tomar decisiones de movimiento basadas en la geometría del entorno y la ubicación relativa del objetivo y los obstáculos. Esto permite que el robot navegue de manera eficiente y evite colisiones al seguir la tangente de los obstáculos en lugar de intentar rodearlos completamente.\\

  \textbf{Autonomous Mobile Robot Navigation Using Tangent Bug Algorithm} por Arvind Yadav, Vimal Kumar, y Sanyam Anand. El artículo propone la aplicación del algoritmo TangentBug para la navegación autónoma de robots móviles en entornos desconocidos. Se describe cómo el algoritmo utiliza sensores de distancia para seguir el perfil de un obstáculo y encontrar una ruta alrededor de él.

  \newpage
\item ¿Podría describir, en forma de pseudocódigo, el algoritmo necesario para seguir el perfil de un muro empleando sensores de distancia?

  %% This declares a command \Comment
  %% The argument will be surrounded by /* ... */
  \SetKwComment{Comment}{/* }{ */}
  \RestyleAlgo{ruled}
  \begin{algorithm}
    \caption{Algoritmo para seguir el perfil de un muro}\label{alg:one}
    Inicializar variables y configurar los sensores de distancia\;
    Obtener la lectura de los sensores de distancia y almacenarla en una variable $distancia$\;
    \While{No se haya alcanzado el objetivo}{
      \If{la distancia es menor que el umbral predefinido}{
        Girar hacia la derecha o la izquierda\;
      }
      \If{Si la distancia es mayor que el umbral predefinido}{
        Mover hacia adelante durante un tiempo predefinido para acercarse al muro\;
      }
      Actualizar la lectura de los sensores de distancia\;
    }
  \end{algorithm}


\end{itemize}

\end{document}
